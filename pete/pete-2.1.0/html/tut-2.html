<!-- tut-2.html : second PETE tutorial -->
<!-- $Id: tut-2.html,v 1.1 2001/08/10 15:24:14 ckees Exp $ -->

<html>
<head>
<title>PETE Tutorial 2: Integrating with the Standard Template Library</title>
</head>
<body bgcolor="#ffffff" link="#0099cc" alink="#0099cc" vlink="#cc6600">

<h1><center><img src="banner.gif" width="432" height="108" align="BOTTOM"
border="0" naturalsizeflag="3"></CENTER></h1>

<center><h1>PETE Tutorial 2<br>Integrating with the Standard Template Library</h1></center>

<p><b>Contents:</b>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#intro">Introduction</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#definitions">Required Definitions</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#conform">Checking Conformance</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#using">Using Vectors with PETE</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#summary">Summary</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#source-files">Source Files</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#eval-h"><tt>Eval.h</tt></a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#vectordefs-in"><tt>VectorDefs.in</tt></a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#vector-cpp"><tt>Vector.cpp</tt></a>

<!---------------------------------------------------------------------->
<a name="intro"><h2>Introduction</h2></a>

<p>This tutorial shows how to use PETE to manipulate expressions
involving classes taken from pre-existing libraries---in this case,
from the C++ Standard Template Library (STL).  The STL's
<tt>vector&lt;&gt;</tt> class is a generic resizeable one-dimensional
array, which provides fast, constant-time element access in exchange
for making extension expensive.  Like the STL's other container
classes, <tt>vector&lt;&gt;</tt> is used both as-is, and as a basis
for more specialized data structures, such as fixed-size queues and
stacks.  This tutorial will show how to use PETE to improve the
performance of elementwise expressions on numeric vectors, and how to
automatically determine whether two or more vectors conform (i.e. have
the same length).

<p>The source files for this example are included in the
<tt>examples/Vector</tt> directory of the PETE distribution.  These
files are:

<ul>

<li><a href="#eval-h"><tt>Eval.h</tt></a>: extends PETE's standard
definitions to accommodate expressions involving
<tt>vector&lt;&gt;</tt>s.

<li><a href="#vectordefs-in"><tt>VectorDefs.in</tt></a>: definitions
needed to automatically generate the overloaded operators required to
integrate <tt>vector&lt;&gt;</tt>s into PETE.  As in the <a
href="#tut-1.html#make-expr-operators">first tutorial</a>, this file
is processed by the <tt>MakeOperators</tt> tool to create a header
file.

<li><tt>VectorOperators.h</tt>: the file generated by
<tt>MakeOperators</tt> based on the definitions in
<tt>VectorDefs.in</tt>.  The file <tt>Eval.h</tt> <tt>#include</tt>s
<tt>VectorOperators.h</tt>, so that PETE-based programs only need to
<tt>#include</tt> <tt>Eval.h</tt>, rather than both <tt>Eval.h</tt>
and <tt>VectorOperators.h</tt>.

<li><a href="#vector-cpp"><tt>Vector.cpp</tt></a>: a short program
that shows how to use the definitions in the header files described
above to create values during compilation.

<li><tt>makefile</tt>: rebuilds the example.

</ul>

<!---------------------------------------------------------------------->
<a name="definitions"><h2>Required Definitions</h2></a>

<p>Most of the definitions required to integrate
<tt>vector&lt;&gt;</tt> with PETE are generated automatically by
<tt>MakeOperators</tt> using the information in
<tt>VectorDefs.in</tt>.  The file <tt>Eval.h</tt> contains the few
extra definitions that must be written by hand.  Of these, the most
important is the function <tt>evaluate()</tt>, on lines 102-128.  This
function's arguments are:

<ul>

<li>a <tt>vector&lt;T, Allocator&gt;</tt> (for some type <tt>T</tt> and
some allocator <tt>Allocator</tt>);

<li>an operator specified by an instance of a PETE operator tag class;
and

<li>a wrapped PETE expression, called <tt>rhs</tt>, the values of which are to be
assigned to the elements of the given <tt>vector&lt;&gt;</tt>.

</ul>

<p>The overloaded assignment operators in <tt>VectorOperators.h</tt>
must be able to find an <tt>evaluate()</tt> to match
every assignment in the user's program.  PETE's protocol therefore
requires that every class used on the left-hand-side (LHS) in assignment
expressions define a function with this name and signature.

<p>The first thing <tt>evaluate()</tt> does is check that its target
and expression conform, i.e. have the same length.  It does this by
applying the PETE function <tt>forEach()</tt> with a user-defined
functor <tt>SizeLeaf()</tt> to the expression <tt>rhs</tt> on
line&nbsp;115. This functor returns <tt>true</tt> if the size of each
<tt>vector&lt;&gt;</tt> at a leaf of PETE's expression tree matches the
size of the LHS vector, which is passed as a contructor argument to the
<tt>SizeLeaf</tt>. We use an <tt>AndCombine</tt> object to
combine results at non-leaf nodes. In order for the right-hand-side (RHS)
to conform, all leaves must agree. The definition of <tt>SizeLeaf</tt>
is discussed <a href="#conform">below</a>.

<p>If its expression and target conform, <tt>evaluate()</tt> carries
out the required assignment by looping over their mutual index range
(line&nbsp110).  For each index value, <tt>forEach()</tt> is used to
evaluate the expression, and the given assignment operator's
overloaded <tt>operator()</tt> method is used to transfer those values
to the target vector.  Note that a direct assignment is not used,
since the assignment could involve <tt>+=</tt>, <tt>|=</tt>, or any
one of C++'s other combine-and-assign operators.

<p>The two other definitions that must be present for PETE to work
with <tt>vector&lt;&gt;</tt> are specializations of
<tt>CreateLeaf&lt;&gt;</tt> and 
<tt>LeafFunctor&lt;&gt;</tt>.  The first one of these
specializations, on lines 29-35, specifies that we store
references to the <tt>vector&lt;&gt;</tt> objects themselves at the
leaves of the PETE expression tree.

<p>The specialization of <tt>LeafFunctor&lt;&gt;</tt> for
<tt>vector&lt;&gt;</tt> and <tt>EvalLeaf1</tt> on lines 86-95 is
what tells PETE how to extract elements from a
<tt>vector&lt;&gt;</tt>. The '1' in <tt>EvalLeaf1</tt> indicates
that the class is used to access singly-indexed structures; similar
classes called <tt>EvalLeaf2</tt>, <tt>EvalLeaf3</tt>, and so on
are used to access more complex classes.

<p>Given an instance of <tt>EvalLeaf1</tt>, and a
<tt>vector&lt;&gt;</tt>, this specialization of
<tt>LeafFunctor&lt;&gt;</tt> defines a <tt>inline</tt> <tt>static</tt>
method called <tt>apply()</tt>, which takes the index value stored in
the <tt>EvalLeaf1</tt> and fetches the corresponding
<tt>vector&lt;&gt;</tt> element.  Making this method <tt>static</tt>
means that instances of <tt>LeafFunctor&lt;&gt;</tt> never have to be
created, while making it <tt>inline</tt> ensures that the compiler
will replace uses of it with its body.  Thus, specializations of
<tt>LeafFunctor&lt;&gt;</tt> present container element access to
compilers in a uniform way, without any efficiency cost.

<p>Finally, the <tt>VectorDefs.in</tt> file, which is used to generate
the standard operator overloadings for <tt>vector&lt;&gt;</tt>, is
identical to the one used in the <a
href="tut-1.html#vec3defs-in">previous tutorial</a>, except for a
substitution of <tt>vector&lt;T[n]&gt;</tt> for <tt>Vec3</tt>.
(Recall that the <tt>[n]</tt> notation is a placeholder for an
automatically generated index, so that if <tt>vector&lt;&gt;</tt> is
used as a formal parameter two or more times, the instances will be
labeled <tt>vector&lt;T1&gt;</tt>, <tt>vector&lt;T2&gt;</tt>, and so
on.)

<!---------------------------------------------------------------------->
<a name="conform"><h2>Checking Conformance</h2></a>

<p>Our only remaining task is to implement the conformance checking
used by <tt>evaluate()</tt>.  The first step is to write a simple
functor that holds a size to compare against and contains a method
to return whether an argument matches this value. This is the
<tt>Sizefunctor</tt> class appearing in lines 43-55 of <tt>Eval.h</tt>.

<p>Once we've created the functor class, we then need to tell PETE
how to apply it at the leaves of the expression tree. We know that
these leaves can consist of either <tt>Scalar&lt;&gt;</tt> or 
<tt>vector&lt;&gt;</tt> objects. We therefore need to supply two
<tt>LeafFunctor&lt;&gt;</tt> specializations. The first, in lines 57-68
works for scalars and always returns <tt>true</tt> since scalars always
conform. The second, in lines 70-79, uses <tt>SizeLeaf</tt>'s 
<tt>operator()</tt> function to compare the size of the 
<tt>vector&lt;&gt;</tt> object stored at a leaf with the reference value.


<!---------------------------------------------------------------------->
<a name="using"><h2>Using Vectors with PETE</h2></a>

<p>The program in <a href="vector-cpp"><tt>Vector.cpp</tt></a> shows
how to use the definitions given above.  The program starts by
creating and initializing five vectors.  It then calls PETE's
<tt>assign()</tt> function to evaluate expressions involving vectors
and scalars, and copy their values into other vectors.  Note that
<tt>assign()</tt> must be called by name because the STL pre-defines
<tt>operator=</tt> for all of its types.

<!---------------------------------------------------------------------->
<a name="summary"><h2>Summary</h2></a>

<p>This tutorial has shown how to extend PETE so that it can handle
expressions involving classes taken from a pre-existing library---in
this case, the Standard Template Library.  The definitions required to
do this are simple and well-defined, as are the definitions required
to perform other calculations (in this case, conformance checking) on
those pre-defined classes.

<!---------------------------------------------------------------------->
<a name="source-files"><h2>Source Files</h2></a>

<! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ->
<a name="eval-h"><h3><tt>Eval.h</tt></h3></a>

<blockquote><pre><!-- start-line-numbering -->
001  #ifndef PETE_EXAMPLES_VECTOR_EVAL_H
002  #define PETE_EXAMPLES_VECTOR_EVAL_H
003  
004  //-----------------------------------------------------------------------------
005  // Includes
006  //-----------------------------------------------------------------------------
007  
008  #include &lt;iostream.h&gt;
009  #include &lt;vector.h&gt;
010  #include "PETE/PETE.h"
011  #include "VectorOperators.h"
012  
013  //-----------------------------------------------------------------------------
014  // This file contains several class definitions that are used to evaluate
015  // expressions containing STL vectors.  The main function defined at the end
016  // is evaluate(lhs,op,rhs), which allows the syntax:
017  // vector&lt;int&gt; a,b,c;
018  // evaluate(a,OpAssign(),b+c);
019  //
020  // evaluate() is called by all the global assignment operator functions
021  // defined in VectorOperators.h
022  //-----------------------------------------------------------------------------
023  
024  //-----------------------------------------------------------------------------
025  // We need to specialize CreateLeaf&lt;T&gt; for our class, so that operators
026  // know what to stick in the leaves of the expression tree.
027  //-----------------------------------------------------------------------------
028  
029  template&lt;class T, class Allocator&gt;
030  struct CreateLeaf&lt;vector&lt;T, Allocator&gt; &gt;
031  {
032    typedef Reference&lt;vector&lt;T&gt; &gt; Leaf_t;
033    inline static
034    Leaf_t make(const vector&lt;T, Allocator&gt; &amp;a) { return Leaf_t(a); }
035  };
036  
037  //-----------------------------------------------------------------------------
038  // We need to write a functor that is capable of comparing the size of
039  // the vector with a stored value. Then, we supply LeafFunctor specializations
040  // for Scalar&lt;T&gt; and STL vector leaves.
041  //-----------------------------------------------------------------------------
042  
043  class SizeLeaf
044  {
045  public:
046  
047    SizeLeaf(int s) : size_m(s) { }
048    SizeLeaf(const SizeLeaf &amp;model) : size_m(model.size_m) { }
049    bool operator()(int s) const { return size_m == s; }
050    
051  private:
052    
053    int size_m;
054    
055  };
056  
057  template&lt;class T&gt;
058  struct LeafFunctor&lt;Scalar&lt;T&gt;, SizeLeaf&gt;
059  {
060    typedef bool Type_t;
061    inline static
062    bool apply(const Scalar&lt;T&gt; &amp;, const SizeLeaf &amp;) 
063    {
064      // Scalars always conform.
065      
066      return true;
067    }
068  };
069  
070  template&lt;class T, class Allocator&gt;
071  struct LeafFunctor&lt;vector&lt;T, Allocator&gt;, SizeLeaf&gt;
072  {
073    typedef bool Type_t;
074    inline static
075    bool apply(const vector&lt;T, Allocator&gt; &amp;v, const SizeLeaf &amp;s) 
076    {
077      return s(v.size());
078    }
079  };
080  
081  //-----------------------------------------------------------------------------
082  // EvalLeaf1 is used to evaluate expression with vectors.
083  // (It's already defined for Scalar values.)
084  //-----------------------------------------------------------------------------
085  
086  template&lt;class T, class Allocator&gt;
087  struct LeafFunctor&lt;vector&lt;T, Allocator&gt;,EvalLeaf1&gt;
088  {
089    typedef T Type_t;
090    inline static
091    Type_t apply(const vector&lt;T, Allocator&gt;&amp; vec,const EvalLeaf1 &amp;f)
092    {
093      return vec[f.val1()];
094    }
095  };
096  
097  //-----------------------------------------------------------------------------
098  // Loop over vector and evaluate the expression at each location.
099  //-----------------------------------------------------------------------------
100  
101  template&lt;class T, class Allocator, class Op, class RHS&gt;
102  inline void evaluate(vector&lt;T, Allocator&gt; &amp;lhs, const Op &amp;op, 
103    const Expression&lt;RHS&gt; &amp;rhs)
104  {
105    if (forEach(rhs, SizeLeaf(lhs.size()), AndCombine()))
106      {
107        // We get here if the vectors on the RHS are the same size as those on
108        // the LHS.
109        
110        for (int i = 0; i &lt; lhs.size(); ++i)
111          {
112            // The actual assignment operation is performed here.
113            // PETE operator tags all define operator() to perform the operation.
114            // (In this case op performs an assignment.) forEach is used 
115            // to compute the rhs value.  EvalLeaf1 gets the
116            // values at each node using random access, and the tag 
117            // OpCombine tells forEach to use the operator tags in the expression 
118            // to combine values together.
119  
120            op(lhs[i], forEach(rhs, EvalLeaf1(i), OpCombine()));
121          }
122      }
123    else
124      {
125        cerr &lt;&lt; "Error: LHS and RHS don't conform." &lt;&lt; endl;
126        exit(1);
127      }
128  }
129  
130  #endif // PETE_EXAMPLES_VECTOR_EVAL_H
</pre></blockquote><!-- end-line-numbering -->

<! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ->
<a name="vectordefs-in"><h3><tt>VectorDefs.in</tt></h3></a>

<blockquote><pre><!-- start-line-numbering -->
001  classes
002  -----
003    ARG   = "class T[n]"
004    CLASS = "vector&lt;T[n]&gt;"
</pre></blockquote><!-- end-line-numbering -->

<! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ->
<a name="vector-cpp"><h3><tt>Vector.cpp</tt></h3></a>

<blockquote><pre><!-- start-line-numbering -->
001  #include "Eval.h"
002
003  int main()
004  {
005    int i;
006    const int n = 10;
007    vector&lt;int&gt; a, b, c, d;
008    vector&lt;double&gt; e(n);
009
010    for (i = 0; i &lt; n; ++i)
011    {
012      a.push_back(i);
013      b.push_back(2*i);
014      c.push_back(3*i);
015      d.push_back(i);
016    }
017
018    assign(b, 2);
019    assign(d, a + b * c);
020    a += where(d &lt; 30, b, c);
021
022    assign(e, c);
023    e += e - 4 / (c + 1);
024
025    for (i = 0;i &lt; n; ++i)
026      {
027        cout &lt;&lt; " a(" &lt;&lt; i &lt;&lt; ") = " &lt;&lt; a[i]
028          &lt;&lt; " b(" &lt;&lt; i &lt;&lt; ") = " &lt;&lt; b[i]
029          &lt;&lt; " c(" &lt;&lt; i &lt;&lt; ") = " &lt;&lt; c[i]
030          &lt;&lt; " d(" &lt;&lt; i &lt;&lt; ") = " &lt;&lt; d[i]
031          &lt;&lt; " e(" &lt;&lt; i &lt;&lt; ") = " &lt;&lt; e[i]
032          &lt;&lt; endl;
033      }
034  }
</pre></blockquote><!-- end-line-numbering -->

<br>
<br>
<center>
<table>
<tr>	<td><a href="tut-1.html">[Prev]</a>
	<td><a href="index.html">[Home]</a>
	<td><a href="tut-3.html">[Next]</a>
	</tr>
</table>
<em>
<a href="http://www.acl.lanl.gov/pete/">Copyright &copy; Los Alamos National Laboratory 1999</a>
</em>
</center>
