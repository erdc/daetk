<!-- tut-1.html : first PETE tutorial -->
<!-- $Id: tut-1.html,v 1.1 2001/08/10 15:24:14 ckees Exp $ -->

<html>
<head>
<title>PETE Tutorial 1: Incorporating a Simple Vector Class</title>
</head>
<body bgcolor="#ffffff" link="#0099cc" alink="#0099cc" vlink="#cc6600">

<h1><center><img src="banner.gif" width="432" height="108" align="BOTTOM"
border="0" naturalsizeflag="3"></CENTER></h1>

<center><h1>PETE Tutorial 1<br>Incorporating a Simple Vector Class</h1></center>

<p><b>Contents:</b>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#intro">Introduction</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#starting-point">The Starting Point</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#integration">Extra Definitions Required for Integration</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#make-leaf">Making Leaves for the Parse Tree</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#leaf-functor">Operating on Leaves</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#assignment">Assigning to Vectors</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#counting">Counting Vectors</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#make-expr-operators">Making Operators</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#using">Using These Definitions</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#summary">Summary</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#source-files">Source Files</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#vec3-h"><tt>Vec3.h</tt></a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#vec3defs-in"><tt>Vec3Defs.in</tt></a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#vec3-cpp"><tt>Vec3.cpp</tt></a>

<!---------------------------------------------------------------------->
<a name="intro"><h2>Introduction</h2></a>

<p>This tutorial shows how to integrate a simple class representing
3-element vectors into PETE.  The source files for this example are
included in the <tt>examples/Vec3</tt> directory of the PETE
distribution.  These files are:

<ul>

<li><a href="#vec3-h"><tt>Vec3.h</tt></a>: defines the <tt>Vec3</tt>
class on which the example is based.  This file also defines or
specializes the template classes needed to integrate <tt>Vec3</tt>
with PETE.  These extra definitions will be discussed <a
href="#integration">below</a>.

<li><a href="#vec3defs-in"><tt>Vec3Defs.in</tt></a>: definitions
needed to automatically generate the template classes required to
integrate <tt>Vec3</tt> into PETE.  This file is processed by the
<tt>MakeOperators</tt> tool discussed <a
href="#make-expr-operators">below</a>.

<li><tt>Vec3Operators.h</tt>: the file generated by
<tt>MakeOperators</tt> based on the definitions in
<tt>Vec3Defs.in</tt>.  The vector class definition file
<tt>Vec3.h</tt> <tt>#include</tt>s this file, so that PETE-based
programs only need to <tt>#include</tt> <tt>Vec3.h</tt>, rather than
both <tt>Vec3.h</tt> and <tt>Vec3Operators.h</tt>.

<li><a href="#vec3-cpp"><tt>Vec3.cpp</tt></a>: a short program that
shows how to construct expressions using <tt>Vec3</tt> and PETE
together.

<li><tt>makefile</tt>: rebuilds the example.

</ul>

<!---------------------------------------------------------------------->
<a name="starting-point"><h2>The Starting Point</h2></a>

<p>The starting point for this tutorial is the 3-element vector class
defined in <a href="#vec3-h"><tt>Vec3.h</tt></a>.  Most of this
class's declaration is unremarkable.  Each instance of the class
contains a 3-element array of integers; the class's default
constructor initializes their values to 0, while a non-default
constructor can be used to give them particular initial values.  A
copy constructor is also provided, as are assignment operators taking
either scalar or vector values.  Finally, two versions of
<tt>operator[]</tt> are provided, so that both constant and
non-constant vectors can be indexed, and a <tt>print()</tt> method is
defined for <tt>operator&lt;&lt;</tt> and other I/O routines to use.
<tt>operator&lt;&lt;</tt> is overloaded further down, on lines
115-119.

<p>If you do not understand all of the definitions on lines 22-58 and
78-94 of <a href="#vec3-h"><tt>Vec3.h</tt></a>, you may wish to
become more familiar with C++ before proceeding with these tutorials.

<p>In order to understand the particulars of this tutorial, it is
necessary to know about some of the indirection classes that PETE
uses.  The most important of these is a general wrapper called
<tt>Expression&lt;&gt</tt>.  It exists to wrap
<tt>UnaryNode&lt;&gt;</tt>, <tt>BinaryNode&lt;&gt;</tt> and
<tt>TrinaryNode&lt;&gt;</tt> so that they can all be captured during
template expansion by a single type, namely
<tt>Expression&lt;T&gt;</tt>.  As we shall see <a
href="#assignment">below</a>, the <tt>Expression&lt;&gt;</tt> template
also serves to distinguish PETE expressions from other expressions, so
that the compiler will not inadvertently mix PETE expressions with
normal arithmetic.

<p>PETE's second indirection class is called
<tt>MakeReturn&lt;&gt;</tt>.  For any type <tt>T</tt>,
<tt>MakeReturn&lt;T&gt;::Expression_t</tt> is a <tt>typedef</tt> that
produces the type of value returned by expressions on <tt>T</tt>.  In
the general case, this is simply Expression&lt;T&gt;,
i.e. <tt>MakeReturn&lt;&gt;</tt> just wraps the expression produced by
an operator so that it can be used inside other operators.  The <a
href="http://www.acl.lanl.gov/pooma">POOMA</a> library overrides
<tt>MakeReturn&lt;T&gt;</tt> (by specializing it explicitly) so that
expressions involving POOMA arrays generate new arrays.  This
technique is similar to the standard C++ idiom of having a framework
define one or more virtual methods with empty bodies, and call them at
specified times, so that users can derive from the framework classes
and override those virtual methods to insert their own code in the
framework's processing stream.

<!---------------------------------------------------------------------->
<a name="integration"><h2>Extra Definitions Required for Integration</h2></a>

<p>In order to use <tt>Vec3</tt> with PETE, we must provide three
things:
<ol>
<li>A description of the <tt>Vec3</tt> class.
<li>A way to extract values from instances of <tt>Vec3</tt>.
<li>A way to assign to a <tt>Vec3</tt> from a PETE expression.
</ol>
These three issues are discussed in order below.

<p>In addition, this example shows how to add new capabilities to PETE
by creating a mechanism for counting the number of instances of
<tt>Vec3</tt> involved in an expression.  The same kind of mechanism
can be used to (for example) check that all of the vectors in an
expression have the same length before starting evaluation of that
expression.

<! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ->
<a name="make-leaf"><h3>Making Leaves for the Parse Tree</h3></a>

<p>PETE uses a traits class called <tt>CreateLeaf&lt;&gt;</tt> to
record information about the leaf types on which it operates.  Each
specialization of <tt>CreateLeaf&lt;&gt;</tt> must be able to
answer two questions:
<ol>
<li>What is the type of the leaf?
<li>How can the program make an instance of this leaf?
</ol>

<p>The first question is answered by providing a <tt>typedef</tt> for
the name <tt>Leaf_t</tt>.  In our example, we want to have access to
<tt>Vec3</tt>'s member functions. However, <tt>Vec3</tt> has deep copy
semantics so we don't want store actual <tt>Vec3</tt> objects at the leaves,
thereby making copies and negating most of the benefit of expression
templates.
Instead, we store a <tt>Vec3&amp;</tt>. This is accomplished by wrapping
the <tt>Vec3</tt> class in a <tt>Reference&lt;&gt;</tt> wrapper.
By default, PETE stores leaves by value, which is appropriate
for leaves that hold iterators. In this case we would not have to
make use of the <tt>Reference&lt;&gt;</tt> wrapper.
Once we have done
this, the rest of PETE can be written using expressions like
<tt>CreateLeaf&lt;T&gt;::Leaf_t</tt>.  This allows PETE to work with
classes that are added later, in the same way that making a function
<tt>virtual</tt> allows programs that use a library to add new
functionality without re-writing old code.

<p>Making a leaf is a little bit trickier.  Every
specialization of <tt>CreateLeaf&lt;&gt;</tt> must define a
<tt>static</tt> method called <tt>make()</tt> that takes something of
the specialization's input type as an argument, and returns something
of its leaf type.  This method must be <tt>static</tt> so that
it can be called without an instance of
<tt>CreateLeaf&lt;Vec3&gt;</tt> ever having been created; as with most
traits classes, the specializations of <tt>CreateLeaf&lt;&gt;</tt>
exist only to answer questions.  In this example, the input to
<tt>make()</tt> is a constant reference to a <tt>Vec3</tt>, which the
function simply returns wrapped in a <tt>Reference&lt;Vec3&gt;</tt> object.  
In the case of an STL list, the argument
would have type <tt>List&lt;T&gt;</tt>, but the return type
<tt>Leaf_t</tt> might be an iterator type.

<blockquote><pre>
103  template&lt;&gt;
104  struct CreateLeaf&lt;Vec3&gt;
105  {
106    typedef Reference&lt;Vec3&gt; Leaf_t;
107    inline static
108    Leaf_t make(const Vec3 &amp;a) { return Leaf_t(a); }
109  };
</pre></blockquote>


<! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ->
<a name="leaf-functor"><h3>Operating on Leaves</h3></a>

<p>Our next task is to provide a way for PETE expressions to extract
values from <tt>Vec3</tt>s.  This has to be done in a generic way, so
that (for example) scalars can return the same value each time they
are queried, while STL lists are accessed through bidirectional
iterators and <tt>Vec3</tt>s are accessed by integer indexing.

<p>PETE's solution to this problem is to require programmers to
specialize the traits class <tt>LeafFunctor&lt;&gt;</tt> for the
combination of their leaf class and a tag class called
<tt>EvalLeaf1</tt>.  <tt>EvalLeaf1</tt> is a simple class
defined by PETE, whose only purpose is to contain the single
index that PETE wants to evaluate an expression at.  (<tt>EvalLeaf2</tt>
signals that a doubly-indexed expression is being evaluated, and so
on up to <tt>EvalLeaf7</tt>.)

<p>The specialization of <tt>LeafFunctor&lt;&gt;</tt>, shown below,
does two things.  First, it defines the type of the result of the
expression as <tt>Type_t</tt>.  Second, it defines a <tt>static</tt>
method called <tt>apply()</tt>, which uses the index stored in its
<tt>EvalLeaf1</tt> argument and returns the corresponding element
of the <tt>Vec3</tt>:

<blockquote><pre>
127  template&lt;&gt;
128  struct LeafFunctor&lt;Vec3, EvalLeaf1&gt;
129  {
130    typedef int Type_t;
131    static Type_t apply(const Vec3 &amp;a, const EvalLeaf1 &amp;f)
132      { return a[f.val1()]; }
133  };
</pre></blockquote>

<! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ->
<a name="assignment"><h3>Assigning to Vectors</h3></a>

<p>The last step in making <tt>Vec3</tt> PETE-compatible is to provide
a way for PETE to assign to a <tt>Vec3</tt> from an arbitrary
expression.  This is done by overloading <tt>operator=</tt> to take a
PETE expression as input, and copy values into its owner:

<blockquote><pre>
064    template&lt;class RHS&gt;
065    Vec3 &amp;operator=(const Expression&lt;RHS&gt; &amp;rhs)
066    {
067      d[0] = forEach(rhs, EvalLeaf1(0), OpCombine());
068      d[1] = forEach(rhs, EvalLeaf1(1), OpCombine());
069      d[2] = forEach(rhs, EvalLeaf1(2), OpCombine());
070  
071      return *this;
072    }
</pre></blockquote>

<p>The first thing to notice about this method is that it is templated
on an arbitrary class <tt>RHS</tt>, but its single formal parameter
has type <tt>Expression&lt;RHS&gt;</tt>.  This combination means that
the compiler can match it against anything that is wrapped in the
generic PETE template <tt>Expression&lt;&gt;</tt>, and <em>only</em>
against things that are wrapped in that way.  The compiler cannot
match against <tt>int</tt>, <tt>complex&lt;short&gt;</tt>, or
<tt>GreatAuntJane_t</tt>, since these do not have the form
<tt>Expression&lt;RHS&gt;</tt> for some type <tt>RHS</tt>.

<p>The <tt>forEach</tt> function is used to traverse expression trees.
The first argument is the expression. The second argument is the leaf
tag denoting the operation applied at the leaves. 
The third argument is a combiner tag,
which is used to combine results at non-leaf nodes. By passing
<tt>EvalLeaf1(0)</tt> in line 67, we are indicating that we want the
<tt>Vec3</tt>s at the leaves to return the element at index 0. The
<tt>LeafFunctor&lt;Scalar&lt;T&gt;, EvalLeaf1&gt;</tt> (defined
inside of PETE) ensures that scalars return their value no matter the
index. While <tt>EvalLeaf1</tt> obtains values from the leaves,
<tt>OpCombine</tt> takes these values and combines them according to the
operators present at the non-leaf nodes. The result is that line 67
evaluates the expression on the right side of the assignment operator at
index 0. Line 68 does this at index 1, and so on. Once evaluation is complete,
<tt>operator=</tt> returns the <tt>Vec3</tt> to which values have been
assigned, in keeping with normal C++ conventions.

<! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ->
<a name="counting"><h3>Counting Vectors</h3></a>

<p>We could stop at this point, but in order to show off PETE's
flexibility, we will finish by defining a new leaf tag that counts the
number of <tt>Vec3</tt>s in an arbitrary expression.  The required
definitions, on lines 152-168 of <tt>Vec3.h</tt>, are:

<blockquote><pre>
141  struct CountLeaf { };
142  
143  template&lt;&gt;
144  struct LeafFunctor&lt;Vec3, CountLeaf&gt;
145  {
146    typedef int Type_t;
147    static Type_t apply(const Vec3 &amp;, const CountLeaf &amp;)
148      { return 1; }
149  };
150  
151  template&lt;class T&gt;
152  struct LeafFunctor&lt;T, CountLeaf&gt;
153  {
154    typedef int Type_t;
155    static Type_t apply(const T &amp;a, const CountLeaf &amp;)
156      { return 0; }
157  };
</pre></blockquote>

<p><tt>CountLeaf</tt> is an empty tag class, whose only purpose is
to identify the operation we wish to carry out.
<tt>LeafFunctor&lt;&gt;</tt> is then specialized separately for
<tt>CountLeaf</tt> on both <tt>Vec3</tt> and the generic type
<tt>T</tt>.  Applying the first specialization returns 1, since it
wraps a single <tt>Vec3</tt>.  Applying the second specialization
returns 0, since nothing else counts as a vector.

<!---------------------------------------------------------------------->
<a name="make-expr-operators"><h2>Making Operators</h2></a>

<p>We have now provided almost everything that PETE needs in order to
operate on our <tt>Vec3</tt> class.  All that remains is several
thousand lines of templated operator and function definitions.
Luckily, these can be generated automatically from a few lines of
information.

<p>The file <a href="#vec3defs-in"><tt>Vec3Defs.in</tt></a> stores
exactly that information, and is used by PETE's
<tt>MakeOperators</tt> tool to generate the 3740 lines of
<tt>Vec3Operators.h</tt>.  The special notation <tt>"[n]"</tt> is
replaced by the digits 1, 2, and so on to distinguish multiple uses of
the same argument.  Thus, <tt>"class&nbsp;T[n]"</tt> becomes
<tt>"class&nbsp;T1"</tt>, <tt>"class&nbsp;T2"</tt>, and so on as
needed.  The entire specification file is:

<blockquote><pre>
001  classes
002  -----
003    ARG   = ""
004    CLASS = "Vec3"
</pre></blockquote>

<p>Two values are specified for each of the classes for which
definitions are to be generated:

<ul>

<li><tt>ARG</tt>: how to make the template arguments needed to define
instances of this class.  <tt>Vec3</tt>'s <tt>ARG</tt> field is empty,
since it is not a templated class.  Giving <tt>class&nbsp;T[n]</tt>
for the <tt>ARG</tt> field for a general <tt>Expression&lt;&gt;</tt>
causes instances of <tt>Expression&lt;&gt;</tt> to be filled in with
<tt>class&nbsp;T1</tt>, <tt>class&nbsp;T2</tt>, and so on.

<li><tt>CLASS</tt>: the name of the class itself.

</ul>

<p>The command used to build an operator definition file from this
input specification is:

<blockquote><pre>
MakeOperators --classes Vec3Defs.in --guard VEC3OPS_H --o Vec3Operators.h
</pre></blockquote>

<p><tt>Vec3Defs.in</tt> is the file shown above. The symbol <tt>VEC3OPS_H</tt> is
copied into the output to guard against multiple inclusion, so that
the output file has the form:

<blockquote><pre>
#ifndef VEC3OPS_H
#define VEC3OPS_H

// <em>...contents of file...</em>

#endif // VEC3OPS_H
</pre></blockquote>

<p>Further information about <tt>MakeOperators</tt> and its command-line
argument can be found on its <a href="makeoperators.html">man page</a>.

<!---------------------------------------------------------------------->
<a name="using"><h2>Using These Definitions</h2></a>

<p>With all this out of the way, we can now write arithmetic
expressions that use <tt>Vec3</tt>, and rely on PETE to optimize them
for us.  The file <a href="#vec3-cpp"><tt>Vec3.cpp</tt></a> shows some
of the possibilities.  The simplest example is straightforward
addition and assignment:

<blockquote><pre>
013    a = b + c;
</pre></blockquote>

<p>which would automatically be translated into something equivalent
to:

<blockquote><pre>
a[0] = b[0] + c[0];
a[1] = b[1] + c[1];
a[2] = b[2] + c[2];
</pre></blockquote>

<p> This snippet would make use of the overloaded <tt>operator+()</tt>
generated by the <tt>MakeOperators</tt> tool in the <tt>Vec3Operators.h</tt>
file and the assignment operator defined above.

<p>This expression could be made much more complex, and PETE would
still eliminate redundant temporaries or loops.  One such expression
is:

<blockquote><pre>
a = sqrt(b*b + c*c);
</pre></blockquote>

<p>which would automatically be translated into something equivalent
to:

<blockquote><pre>
a[0] = sqrt(b[0]*b[0] + c[0]*c[0]);
a[1] = sqrt(b[1]*b[1] + c[1]*c[1]);
a[2] = sqrt(b[2]*b[2] + c[2]*c[2]);
</pre></blockquote>

<p>since PETE provides appropriately-templated overloadings of the
standard mathematical functions like <tt>sqrt()</tt> and
<tt>acos()</tt> as well as overloadings of unary and binary operators.

<p>The next two examples in <a href="#vec3-cpp"><tt>Vec3.cpp</tt></a>
make use of an expression (in this case, the addition of <tt>b</tt>
and <tt>c</tt>) that has been recorded for delayed evaluation.  In
order to do this, the programmer must explicitly specify the type of
the expression being stored, but once this has been done, that
expression can be re-used any number of times.  The statement that
creates the expression is:

<blockquote><pre>
018    const Expression&lt;BinaryNode&lt;OpAdd, Vec3, Vec3&gt; &gt; &amp;expr1 = b + c;
</pre></blockquote>

<p>Its first use is as a source for assignment:

<blockquote><pre>
019    d = expr1;
</pre></blockquote>

<p>It can also be passed to PETE's explicit evaluation function,
called <tt>forEach()</tt>, along with the <tt>CountLeaf</tt>
defined <a href="#counting">earlier</a>, and PETE's built-in
<tt>SumCombine</tt> tag class, in order to count the number of
instances of <tt>Vec3</tt> that appear in the expression:

<blockquote><pre>
022    int num = forEach(expr1, CountLeaf(), SumCombine());
</pre></blockquote>

<p>Note the parentheses after <tt>CountLeaf</tt> and
<tt>SumCombine</tt>.  C++ does not allow raw type names to be used to
instantiate templates; instead, the program must create an unnamed
instance of each tag class by invoking their default constructors.
Since these classes contain no data, and their instances are not used
inside <tt>forEach()</tt>, the compiler optimizes away all of the
associated code.

<p>The remaining examples in <a href="#vec3-cpp"><tt>Vec3.cpp</tt></a>
use <tt>CountLeaf</tt> to inspect more complicated expressions.

<!---------------------------------------------------------------------->
<a name="summary"><h2>Summary</h2></a>

<p>This tutorial has shown how to integrate a simple class into PETE's
expression template framework, so that compilers can optimize
expressions involving instances of that class.  The steps required
are:
<ul>

<li>specializing <tt>CreateLeaf&lt;&gt;</tt> to tell PETE how to store
instances of the user class in parse trees;

<li>specializing <tt>LeafFunctor&lt;&gt;</tt> to extract information
from these leaf nodes;

<li>overloading <tt>operator=</tt> to read values from expressions and
assign them to instances of the user-defined class; and

<li>using PETE's <a
href="#make-expr-operators"><tt>MakeOperators</tt></a> tool to
generate specialized overloadings of C++'s unary, binary, and ternary
operators to work with the user-defined class.

</ul>

<p>In addition, this tutorial showed how to extend PETE's leaf and
combiner tags to calculate values on expression trees during compilation.
The next tutorial will look at how to extend the PETE framework itself
to synthesize new types.

<!---------------------------------------------------------------------->
<a name="source-files"><h2>Source Files</h2></a>

<! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ->
<a name="vec3-h"><h3><tt>Vec3.h</tt></h3></a>

<blockquote><pre><!-- start-line-numbering -->
001  #ifndef PETE_EXAMPLES_VEC3_VEC3_H
002  #define PETE_EXAMPLES_VEC3_VEC3_H
003  
004  //-----------------------------------------------------------------------------
005  // Include files
006  //-----------------------------------------------------------------------------
007  
008  #include "PETE/PETE.h"
009  
010  #include &lt;iostream.h&gt;
011  
012  //-----------------------------------------------------------------------------
013  //
014  // CLASS NAME 
015  //   Vec3
016  //
017  // DESCRIPTION
018  //   A "tiny" three-element expression-template (ET) array class. 
019  //
020  //-----------------------------------------------------------------------------
021  
022  class Vec3
023  {
024  public:
025  
026    //---------------------------------------------------------------------------
027    // Constructors and Destructor
028    //---------------------------------------------------------------------------
029  
030    Vec3() { d[0] = d[1] = d[2] = 0; }
031  
032    Vec3(int i, int j, int k) 
033    {
034      d[0] = i; d[1] = j; d[2] = k;
035    }
036  
037    Vec3(const Vec3 &amp;v) 
038    {
039      d[0] = v.d[0];  d[1] = v.d[1];  d[2] = v.d[2];
040    }
041  
042    ~Vec3() {}
043  
044    //---------------------------------------------------------------------------
045    // Vec3 and scalar assigment operators
046    //---------------------------------------------------------------------------
047  
048    Vec3 &amp;operator=(const Vec3 &amp;v) 
049    {
050      d[0] = v.d[0];  d[1] = v.d[1];  d[2] = v.d[2];
051      return *this;
052    }
053  
054    Vec3 &amp;operator=(int i) 
055    {
056      d[0] = d[1] = d[2] = i;
057      return *this;
058    }
059  
060    //---------------------------------------------------------------------------
061    // Assignment operator taking expression:
062    //---------------------------------------------------------------------------
063  
064    template&lt;class RHS&gt;
065    Vec3 &amp;operator=(const Expression&lt;RHS&gt; &amp;rhs)
066    {
067      d[0] = forEach(rhs, EvalLeaf1(0), OpCombine());
068      d[1] = forEach(rhs, EvalLeaf1(1), OpCombine());
069      d[2] = forEach(rhs, EvalLeaf1(2), OpCombine());
070  
071      return *this;
072    }
073  
074    //---------------------------------------------------------------------------
075    // Indexing operators
076    //---------------------------------------------------------------------------
077  
078    int &amp;operator[](int i)      { return d[i]; }
079    int operator[](int i) const { return d[i]; }
080  
081    //---------------------------------------------------------------------------
082    // Print method used by operator&lt;&lt; free function.
083    //---------------------------------------------------------------------------
084  
085    void print(ostream &amp;os) const 
086    { 
087      os &lt;&lt; "{" &lt;&lt; d[0] &lt;&lt; "," &lt;&lt; d[1] &lt;&lt; "," &lt;&lt; d[2] &lt;&lt; "}";
088    }
089  
090  private:
091  
092    // The underlying complicated data structure
093  
094    int d[3];
095  
096  };
097  
098  //-----------------------------------------------------------------------------
099  // We need to specialize CreateLeaf&lt;T&gt; for our class, so that operators
100  // know what to stick in the leaves of the expression tree.
101  //-----------------------------------------------------------------------------
102  
103  template&lt;&gt;
104  struct CreateLeaf&lt;Vec3&gt;
105  {
106    typedef Reference&lt;Vec3&gt; Leaf_t;
107    inline static
108    Leaf_t make(const Vec3 &amp;a) { return Leaf_t(a); }
109  };
110  
111  //-----------------------------------------------------------------------------
112  // ostream inserter for Vec3s
113  //-----------------------------------------------------------------------------
114  
115  ostream &amp;operator&lt;&lt;(ostream &amp;os, const Vec3 &amp;a)
116  {
117    a.print(os);
118    return os;
119  }
120  
121  //-----------------------------------------------------------------------------
122  // Specialization of LeafFunctor class for applying the EvalLeaf1
123  // tag to a Vec3. The apply method simply returns the array
124  // evaluated at the point.
125  //-----------------------------------------------------------------------------
126  
127  template&lt;&gt;
128  struct LeafFunctor&lt;Vec3, EvalLeaf1&gt;
129  {
130    typedef int Type_t;
131    static Type_t apply(const Vec3 &amp;a, const EvalLeaf1 &amp;f)
132      { return a[f.val1()]; }
133  };
134  
135  //-----------------------------------------------------------------------------
136  // Specialization of LeafFunctor class for applying the CountLeaf
137  // tag to a Vec3. The apply method simply returns 1 for a Vec3 and 0 for
138  // anything else.
139  //-----------------------------------------------------------------------------
140  
141  struct CountLeaf { };
142  
143  template&lt;&gt;
144  struct LeafFunctor&lt;Vec3, CountLeaf&gt;
145  {
146    typedef int Type_t;
147    static Type_t apply(const Vec3 &amp;, const CountLeaf &amp;)
148      { return 1; }
149  };
150  
151  template&lt;class T&gt;
152  struct LeafFunctor&lt;T, CountLeaf&gt;
153  {
154    typedef int Type_t;
155    static Type_t apply(const T &amp;a, const CountLeaf &amp;)
156      { return 0; }
157  };
158  
159  // We put this include at the end because
160  // the operators can't be defined until after Vec3 and
161  // CreateLeaf&lt;Vec3&gt; have been defined.
162  // (Since Vec3 isn't templated the operators aren't just
163  // templates.)
164  
165  #include "Vec3Operators.h"
166  
167  #endif // PETE_EXAMPLES_VEC3_VEC3_H
</pre></blockquote><!-- end-line-numbering -->

<! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ->
<a name="vec3defs-in"><h3><tt>Vec3Defs.in</tt></h3></a>

<blockquote><pre><!-- start-line-numbering -->
001  classes
002  -----
003    ARG   = ""
004    CLASS = "Vec3"
</pre></blockquote><!-- end-line-numbering -->

<! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ->
<a name="vec3-cpp"><h3><tt>Vec3.cpp</tt></h3></a>

<blockquote><pre><!-- start-line-numbering -->
001  #include "Vec3.h"
002  
003  int main()
004  {
005    Vec3 a, b, c;
006  
007    c = 4;
008  
009    b[0] = -1;
010    b[1] = -2;
011    b[2] = -3;
012  
013    a = b + c;
014  
015    cout &lt;&lt; a &lt;&lt; endl;
016  
017    Vec3 d;
018    const Expression&lt;BinaryNode&lt;OpAdd, Vec3, Vec3&gt; &gt; &amp;expr1 = b + c;
019    d = expr1;
020    cout &lt;&lt; d &lt;&lt; endl;
021    
022    int num = forEach(expr1, CountLeaf(), SumCombine());
023    cout &lt;&lt; num &lt;&lt; endl;
024  
025    const Expression&lt;BinaryNode&lt;OpAdd, Vec3, 
026      BinaryNode&lt;OpMultiply, Scalar&lt;int&gt;, Vec3&gt; &gt; &gt; &amp;expr2 = b + 3 * c;
027    num = forEach(expr2, CountLeaf(), SumCombine());
028    cout &lt;&lt; num &lt;&lt; endl;
029    
030    const Expression&lt;BinaryNode&lt;OpAdd, Vec3, 
031      BinaryNode&lt;OpMultiply, Vec3, Vec3&gt; &gt; &gt; &amp;expr3 = b + c * d;
032    num = forEach(expr3, CountLeaf(), SumCombine());
033    cout &lt;&lt; num &lt;&lt; endl;
034  }
</pre></blockquote><!-- end-line-numbering -->

<br>
<br>
<center>
<table>
<tr>	<td><a href="background.html">[Prev]</a>
	<td><a href="index.html">[Home]</a>
	<td><a href="tut-2.html">[Next]</a>
	</tr>
</table>
<em>
<a href="http://www.acl.lanl.gov/pete/">Copyright &copy; Los Alamos National Laboratory 1999</a>
</em>
</center>

</body>
</html>
